Introduction

CI/CD pipelines automate build, testing, and deployment; for this reason, they become attractive targets for attackers: a compromised pipeline can allow malicious code to be injected downstream, credentials to be leaked, or distributed artifacts to be manipulated. The OWASP Guide provides practical recommendations to reduce risk and secure the software delivery chain.

Typical Issues / Causes

    Inadequate access controls in the CI/CD pipeline (excessive identities and permissions for jobs, tokens, or machines).

    Poor secret management (hard-coded credentials, uncontrolled or exposed access to secrets in logs).

    Supply Chain Abuse (Dependency/Artifact): Compromised packages or dependencies that are built and deployed.

    Poisoned Pipeline Execution: Pipelines that execute unverified code (e.g., malicious PRs that trigger jobs with elevated permissions).

    Insecure runner/worker configurations or build images that allow escalation or exfiltration.

    Poor visibility and logging: lack of tracking of build/deploy actions and access.

What to do â€” operational categories (each item can be transformed into a requirement)

1) Pipeline Governance and Design
Define ownership, responsibilities, and approval processes for each stage of the pipeline.
Define policies for what can be executed automatically and what requires human approval.

2) Identity & Access Management for CI/CD
Apply least privilege to accounts, tokens, and service accounts (separate accounts for build, deploy, etc.).
Use Policy-Based Access Control to limit actions on branches, jobs, and artifacts.

3) Secrets Management
Do not store secrets in accessible code or configurations (avoid cleartext env vars).
Integrate a secrets management solution (vault, KMS) with rotation and access auditing.

4) Hardening runner/build workers and images
Use immutable and isolated workers (e.g., ephemeral runners), minimize privileges at the OS/container level.
Scan and harden base images (remove unnecessary tools, patch CVEs).

5) Verify artifact integrity
Sign and verify artifacts (builds, packages, container images) and apply integrity checks before deployment.
Validate sources and dependencies with mechanisms such as SLSA / sigstore / in-toto.

6) Dependency & Supply Chain Controls
Automatic dependency scanning (SCA), blocking versions with critical CVEs, and approval policies for new dependencies.
Minimize trust in external packages: use internal proxies/registers if possible.

7) Trigger and Execution Controls (Flow Control)
Limit what can trigger sensitive jobs (e.g., PRs from forks, triggers on protected branches).
Separate build/test pipelines from pipelines with release privileges.

8) Logging, Monitoring, and Anomaly Detection
Log all critical actions (who initiated the build, what secrets were requested, configuration changes).
Integrate alerts for anomalous executions, unexpected use of secrets, or invalid signatures/artifacts.

9) Automatic Testing & Validation
Integrate SAST/DAST/SCA into the pipeline; perform security tests before merging and deploying.
Automate tests that simulate pipeline attacks (e.g., malicious PRs attempting to exfiltrate secrets).

10) Incident Response and Recovery for CI/CD
Define pipeline compromise playbooks (revoke credentials, isolate runners, rebuild from integrity-verified sources).